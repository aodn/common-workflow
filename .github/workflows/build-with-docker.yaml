name: common_build_with_docker

# Expect the build runs given a docker file, a sample workflow to call this is like below:
# name: Test use common
#
# on:
#  push:
#    branches:
#      - raymond-playground
#
# jobs:
#  build-upload:
#    name: Build upload
#    uses: aodn/common-workflow/.github/workflows/build-with-docker.yaml@main
#    with:
#      artifact: ogcapi-java
#      tag: ''
#      docker_file: Docker.build
#      cmd: mvn -f ogc-api clean package
#      target: ogc-api/target/*.jar

on:
  workflow_call:
    inputs:
      cmd:
        description: 'The cmd to kick start the build in the docker environment. i.e. for maven mvn -f ogc-api clean package'
        type: string
        required: true
      docker_file:
        description: 'A dockerfile name, which create the build environment'
        type: string
        required: true
      artifact:
        description: 'The artifact name'
        required: true
        type: string
      tag:
        description: 'The tag version to build and file name will include the tag name artifact-tag.ext, if no provide then HEAD is use and output file is artifact-SNAPSHOT.ext'
        required: false
        type: string
        default: ''
      target:
        description: 'Full path of output build file, i.e ogc-api/target/*.jar. File extension will be use to create the final upload name'
        required: true
        type: string
      keep_days:
        description: 'How long to keep the output file in github'
        required: false
        type: number
        default: 14

concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

jobs:
  get_upload_filename:
    name: Create upload artficate name
    runs-on: ubuntu-latest
    outputs:
      oname: ${{ steps.gen_file_name.outputs.f }}
    steps:
      - id: gen_file_name
        run: |
          filename=${{ inputs.target }}
          artifact=${{ inputs.artifact }}
          tag=${{ inputs.tag }}
          
          if [ "${tag}" != '' ]; then
            output="${artifact}-${tag}.${filename##*.}";
          else
            output="${artifact}-SNAPSHOT.${filename##*.}";
          fi
          
          echo "File name: $output";
          echo "f=$output" >> $GITHUB_OUTPUT;

  # Determine version using gitversion
  # 'If inputs tag have value, then use it else use gitversion to infer it'
  get_artifact_versioned_name:
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      semVer: ${{ steps.gitversion.outputs.semVer }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0      # must use this else gitversion will fail

      - id: gitversion
        run: |
          artifact=${{ inputs.artifact }}
          filename=${{ inputs.target }}
          tag=${{ inputs.tag }}
          
          if [ "${tag}" == '' ]; then
            echo "Run gitversion";
            docker run --rm -v "$(pwd):/repo" gittools/gitversion:5.12.0-alpine.3.14-6.0 /repo > version.json;
            echo "Parse version";
            semVer=`jq .SemVer version.json`;
          else
            semVer=${tag}
          fi
          
          output=${artifact}-${semVer}.${filename##*.};
          echo "File name: $output";
          echo "semVer=${output}" >> $GITHUB_OUTPUT;

  build:
    name: Create docker container and build artifact
    needs: [get_artifact_versioned_name]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build Docker Image
        uses: docker/build-push-action@v4
        env:
          BUILDER_UID: ${{ runner.uid }}
        with:
          context: .
          file: ${{ inputs.docker_file }}
          load: true
          build-args: BUILDER_UID=${{ env.BUILDER_UID }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache
          tags: ${{ inputs.artifact }}-build:latest

      - name: Run Pipeline Steps
        run: |
          docker run --rm \
            -v ${{ github.workspace }}:/workspace \
            -v ${{ runner.home }}/.m2:/home/builder/.m2 \
            -v ${{ runner.home }}/.cache:/home/builder/.cachejournal/ \
            -v ${{ runner.home }}/bin:${HOME}/bin \
            -w /workspace \
            --entrypoint /bin/bash \
            ${{ inputs.artifact }}-build:latest -c '
            git reset --hard ${{ inputs.tag }}
            git clean --force --force -xd --exclude=web/node_modules
            yarn --cwd web --frozen-lockfile
            ${{ inputs.cmd }}
          '

      - name: Upload artifact name ${{ needs.get_upload_filename.outputs.oname }}
        uses: actions/upload-artifact@v3
        with:
          name: "${{ needs.get_artifact_versioned_name.outputs.semVer }}"
          path: ${{ inputs.target }}
          retention-days: ${{ inputs.keep_days }}        # Same as repo setting
          if-no-files-found: error                       # 'warn' or 'ignore' are also available, defaults to `warn`
